{"ast":null,"code":"import { useEffect, useState, useRef, useCallback } from \"react\";\nimport { fetchMenu } from \"../../store/actions/menuAction\";\nimport { useStore } from \"../../store\";\n\nconst useSticky = () => {\n  const {\n    0: isSticky,\n    1: setSticky\n  } = useState(false);\n  const {\n    0: hideNav,\n    1: setHideNav\n  } = useState(false);\n  const element = useRef(null);\n  const store = useStore();\n\n  if (false) {\n    var prevScrollpos = window.pageYOffset;\n  }\n\n  const handleScroll = () => {\n    var currentScrollPos = window.pageYOffset;\n\n    if (element.current) {\n      if (parseInt(currentScrollPos) <= 0) {\n        setHideNav(false);\n        setSticky(false);\n        return;\n      } else {\n        if (currentScrollPos <= prevScrollpos) {\n          setHideNav(false);\n          setSticky(false);\n        } else {\n          setHideNav(true);\n          setSticky(true);\n          store.dispatch(fetchMenu);\n        }\n      }\n\n      prevScrollpos = currentScrollPos;\n    }\n  }; // This function handle the scroll performance issue\n\n\n  function debounce(func, wait = 20, immediate = true) {\n    let timeOut;\n    return () => {\n      let context = this,\n          args = arguments;\n\n      const later = () => {\n        timeOut = null;\n        if (!immediate) func.apply(context, args);\n      };\n\n      const callNow = immediate && !timeOut;\n      clearTimeout(timeOut);\n      timeOut = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  }\n\n  const scrollHandler = useCallback(() => {\n    debounce(handleScroll());\n  }, []);\n  useEffect(() => {\n    window.addEventListener(\"scroll\", scrollHandler);\n    return () => {\n      window.removeEventListener(\"scroll\", scrollHandler);\n    };\n  }, [debounce, handleScroll]);\n  return {\n    isSticky,\n    element,\n    hideNav\n  };\n};\n\nexport default useSticky;","map":null,"metadata":{},"sourceType":"module"}