{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState, useRef, useCallback } from \"react\";\nimport { fetchMenu } from \"../../store/actions/menuAction\";\nimport { useStore } from \"../../store\";\n\nvar useSticky = function useSticky() {\n  _s();\n\n  var _useState = useState(false),\n      isSticky = _useState[0],\n      setSticky = _useState[1];\n\n  var _useState2 = useState(false),\n      hideNav = _useState2[0],\n      setHideNav = _useState2[1];\n\n  var element = useRef(null);\n  var store = useStore();\n\n  if (true) {\n    var prevScrollpos = window.pageYOffset;\n  }\n\n  var handleScroll = function handleScroll() {\n    var currentScrollPos = window.pageYOffset;\n\n    if (element.current) {\n      if (parseInt(currentScrollPos) <= 0) {\n        setHideNav(false);\n        setSticky(false);\n        return;\n      } else {\n        if (currentScrollPos <= prevScrollpos) {\n          setHideNav(false);\n          setSticky(false);\n        } else {\n          setHideNav(true);\n          setSticky(true);\n          store.dispatch(fetchMenu);\n        }\n      }\n\n      prevScrollpos = currentScrollPos;\n    }\n  }; // This function handle the scroll performance issue\n\n\n  function debounce(func) {\n    var _arguments = arguments,\n        _this = this;\n\n    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n    var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var timeOut;\n    return function () {\n      var context = _this,\n          args = _arguments;\n\n      var later = function later() {\n        timeOut = null;\n        if (!immediate) func.apply(context, args);\n      };\n\n      var callNow = immediate && !timeOut;\n      clearTimeout(timeOut);\n      timeOut = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  }\n\n  var scrollHandler = useCallback(function () {\n    debounce(handleScroll());\n  }, []);\n  useEffect(function () {\n    window.addEventListener(\"scroll\", scrollHandler);\n    return function () {\n      window.removeEventListener(\"scroll\", scrollHandler);\n    };\n  }, [debounce, handleScroll]);\n  return {\n    isSticky: isSticky,\n    element: element,\n    hideNav: hideNav\n  };\n};\n\n_s(useSticky, \"l1wBOa6yktg6E7yzvgI53/fVZUs=\", false, function () {\n  return [useStore];\n});\n\nexport default useSticky;","map":{"version":3,"sources":["/Users/sosokorn/Documents/Project/ten11-web-reactjs-nextjs/shared/hooks/useSticky.js"],"names":["useEffect","useState","useRef","useCallback","fetchMenu","useStore","useSticky","isSticky","setSticky","hideNav","setHideNav","element","store","prevScrollpos","window","pageYOffset","handleScroll","currentScrollPos","current","parseInt","dispatch","debounce","func","wait","immediate","timeOut","context","args","arguments","later","apply","callNow","clearTimeout","setTimeout","scrollHandler","addEventListener","removeEventListener"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,EAA8BC,MAA9B,EAAsCC,WAAtC,QAAyD,OAAzD;AACA,SAASC,SAAT,QAA0B,gCAA1B;AACA,SAASC,QAAT,QAAyB,aAAzB;;AACA,IAAMC,SAAS,GAAG,SAAZA,SAAY,GAAM;AAAA;;AAAA,kBACQL,QAAQ,CAAC,KAAD,CADhB;AAAA,MACfM,QADe;AAAA,MACLC,SADK;;AAAA,mBAEQP,QAAQ,CAAC,KAAD,CAFhB;AAAA,MAEfQ,OAFe;AAAA,MAENC,UAFM;;AAGtB,MAAMC,OAAO,GAAGT,MAAM,CAAC,IAAD,CAAtB;AACA,MAAMU,KAAK,GAAGP,QAAQ,EAAtB;;AAEA,YAAmC;AACjC,QAAIQ,aAAa,GAAGC,MAAM,CAACC,WAA3B;AACD;;AAED,MAAMC,YAAY,GAAG,SAAfA,YAAe,GAAM;AACzB,QAAIC,gBAAgB,GAAGH,MAAM,CAACC,WAA9B;;AACA,QAAIJ,OAAO,CAACO,OAAZ,EAAqB;AACnB,UAAIC,QAAQ,CAACF,gBAAD,CAAR,IAA8B,CAAlC,EAAqC;AACnCP,QAAAA,UAAU,CAAC,KAAD,CAAV;AACAF,QAAAA,SAAS,CAAC,KAAD,CAAT;AACA;AACD,OAJD,MAIO;AACL,YAAIS,gBAAgB,IAAIJ,aAAxB,EAAuC;AACrCH,UAAAA,UAAU,CAAC,KAAD,CAAV;AACAF,UAAAA,SAAS,CAAC,KAAD,CAAT;AACD,SAHD,MAGO;AACLE,UAAAA,UAAU,CAAC,IAAD,CAAV;AACAF,UAAAA,SAAS,CAAC,IAAD,CAAT;AACAI,UAAAA,KAAK,CAACQ,QAAN,CAAehB,SAAf;AACD;AACF;;AAEDS,MAAAA,aAAa,GAAGI,gBAAhB;AACD;AACF,GApBD,CAVsB,CAgCtB;;;AACA,WAASI,QAAT,CAAkBC,IAAlB,EAAqD;AAAA;AAAA;;AAAA,QAA7BC,IAA6B,uEAAtB,EAAsB;AAAA,QAAlBC,SAAkB,uEAAN,IAAM;AACnD,QAAIC,OAAJ;AACA,WAAO,YAAM;AACX,UAAIC,OAAO,GAAG,KAAd;AAAA,UACEC,IAAI,GAAGC,UADT;;AAEA,UAAMC,KAAK,GAAG,SAARA,KAAQ,GAAM;AAClBJ,QAAAA,OAAO,GAAG,IAAV;AACA,YAAI,CAACD,SAAL,EAAgBF,IAAI,CAACQ,KAAL,CAAWJ,OAAX,EAAoBC,IAApB;AACjB,OAHD;;AAIA,UAAMI,OAAO,GAAGP,SAAS,IAAI,CAACC,OAA9B;AACAO,MAAAA,YAAY,CAACP,OAAD,CAAZ;AACAA,MAAAA,OAAO,GAAGQ,UAAU,CAACJ,KAAD,EAAQN,IAAR,CAApB;AACA,UAAIQ,OAAJ,EAAaT,IAAI,CAACQ,KAAL,CAAWJ,OAAX,EAAoBC,IAApB;AACd,KAXD;AAYD;;AAED,MAAMO,aAAa,GAAG/B,WAAW,CAAC,YAAM;AACtCkB,IAAAA,QAAQ,CAACL,YAAY,EAAb,CAAR;AACD,GAFgC,EAE9B,EAF8B,CAAjC;AAIAhB,EAAAA,SAAS,CAAC,YAAM;AACdc,IAAAA,MAAM,CAACqB,gBAAP,CAAwB,QAAxB,EAAkCD,aAAlC;AACA,WAAO,YAAM;AACXpB,MAAAA,MAAM,CAACsB,mBAAP,CAA2B,QAA3B,EAAqCF,aAArC;AACD,KAFD;AAGD,GALQ,EAKN,CAACb,QAAD,EAAWL,YAAX,CALM,CAAT;AAOA,SAAO;AAAET,IAAAA,QAAQ,EAARA,QAAF;AAAYI,IAAAA,OAAO,EAAPA,OAAZ;AAAqBF,IAAAA,OAAO,EAAPA;AAArB,GAAP;AACD,CA7DD;;GAAMH,S;UAIUD,Q;;;AA0DhB,eAAeC,SAAf","sourcesContent":["import { useEffect, useState, useRef, useCallback } from \"react\";\nimport { fetchMenu } from \"../../store/actions/menuAction\";\nimport { useStore } from \"../../store\";\nconst useSticky = () => {\n  const [isSticky, setSticky] = useState(false);\n  const [hideNav, setHideNav] = useState(false);\n  const element = useRef(null);\n  const store = useStore();\n\n  if (typeof window !== \"undefined\") {\n    var prevScrollpos = window.pageYOffset;\n  }\n\n  const handleScroll = () => {\n    var currentScrollPos = window.pageYOffset;\n    if (element.current) {\n      if (parseInt(currentScrollPos) <= 0) {\n        setHideNav(false);\n        setSticky(false);\n        return;\n      } else {\n        if (currentScrollPos <= prevScrollpos) {\n          setHideNav(false);\n          setSticky(false);\n        } else {\n          setHideNav(true);\n          setSticky(true);\n          store.dispatch(fetchMenu);\n        }\n      }\n\n      prevScrollpos = currentScrollPos;\n    }\n  };\n\n  // This function handle the scroll performance issue\n  function debounce(func, wait = 20, immediate = true) {\n    let timeOut;\n    return () => {\n      let context = this,\n        args = arguments;\n      const later = () => {\n        timeOut = null;\n        if (!immediate) func.apply(context, args);\n      };\n      const callNow = immediate && !timeOut;\n      clearTimeout(timeOut);\n      timeOut = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  }\n\n  const scrollHandler = useCallback(() => {\n    debounce(handleScroll());\n  }, []);\n\n  useEffect(() => {\n    window.addEventListener(\"scroll\", scrollHandler);\n    return () => {\n      window.removeEventListener(\"scroll\", scrollHandler);\n    };\n  }, [debounce, handleScroll]);\n\n  return { isSticky, element, hideNav };\n};\nexport default useSticky;\n"]},"metadata":{},"sourceType":"module"}